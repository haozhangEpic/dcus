#  面试题收集

##  webpack怎么执行的

通过 react 项目中的目录结构结合以及 `webpack` 中的 [**Node 接口相关内容**](https://link.juejin.cn?target=https%3A%2F%2Fwebpack.docschina.org%2Fapi%2Fnode%2F%23webpack)，可得到以下几个阶段：

- **解析配置参数** —— 合并 **`shell`** 传入和 **`webpack.config.js`** 文件配置参数

- **初始化 Compiler** —— 通过 **`webpack(config)`** 得到 **`Compiler`** 对象，并注册所有配置插件，插件监听 **`webpack`** 构建生命周期的事件节点，做出相应处理

- **开始编译** —— 调用 **`Compiler`** 对象 **`run()`** 方法开始执行编译

- **确定入口** —— 根据配置的 **`entry`** 找出所有入口文件，开始解析文件，并构建 **`AST`** 语法树，找出依赖模块，进行递归处理

- **编译模块** —— 递归中根据文件类型和 **`loader`** 配置，调用所有配置的 **`loader`** 对文件进行转换，再找出该模块依赖的模块，再递归本步骤，直到所有入口依赖的文件都经过了本步骤的处理

- **完成模块编译** —— 模块编译结束后，得到每个文件结果，包含每个模块以及他们之间的依赖关系

- 输出资源

   —— 根据 

  `entry`

   或分包配置生成代码块 

  `chunk`

  ，再把每个 

  `chunk`

   转换成一个单独的文件加入到输出列表

  > PS：**输出资源** 这一步是修改输出内容的最后机会

- **输出完成** —— 根据配置确定输出路径和命名，输出所有 **`chunk`** 到文件系统

流程图：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/905cabef2d3e4f3780ea88d6806f494f~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)

## 单点登录，多点验证，验证方式

单点登录（Single Sign-On，简称SSO）是一种身份验证机制，允许用户使用一组凭据（如用户名和密码）登录到多个相关但独立的软件系统或应用程序中，而无需重复输入凭据。通过单点登录，用户只需要在第一次登录时提供凭据，之后就可以无缝访问其他相关系统，而无需重新输入凭据。

SSO 的工作原理通常涉及一个称为身份提供者（Identity Provider，IdP）的中心身份验证系统。用户首先登录到 IdP，并获得一个身份验证令牌。然后，当用户尝试访问其他受保护的应用程序时，这些应用程序将请求 IdP 验证该令牌，从而允许用户访问而无需再次提供凭据。

优点：

1. **便捷性**：用户只需一次登录即可访问多个应用程序，提高用户体验。
2. **安全性**：减少了用户需要记忆的凭据数量，降低了密码被盗的风险。
3. **管理简化**：减少了管理员需要管理的凭据数量，降低了系统管理成本。

常见的单点登录实现方式包括：

1. **基于令牌的SSO**：使用令牌进行身份验证，如OAuth、OpenID Connect等。
2. **基于SAML的SSO**：使用安全断言标记语言（Security Assertion Markup Language，SAML）实现单点登录。

总的来说，单点登录是一种方便且安全的身份验证机制，广泛应用于企业内部系统、云服务、门户网站等需要用户认证的场景。

## 单点用户手动更改了token怎么办

## es6新特性

ES6（ECMAScript 2015）引入了许多新的特性，以下是其中一些主要的变化：

1. **let 和 const**：ES6引入了块级作用域的 let 和常量声明的 const，取代了var关键字。
2. **箭头函数**：ES6中可以使用 (params) => expression 的形式定义函数，简化了函数的书写，并且自动绑定上下文。
3. **模板字符串**：ES6中可以使用反引号 (`) 来创建多行字符串和嵌入表达式，提高了字符串处理的便利性。
4. **解构赋值**：ES6允许从数组或对象中轻松提取数据并赋值给变量。
5. **默认参数**：在函数参数中可以指定默认值，简化了函数调用时的参数处理。
6. **类**：ES6引入了class关键字，使得面向对象编程更加直观和易于理解。
7. **模块化**：通过import和export关键字实现了模块化，使得JavaScript代码的组织和复用更加容易。
8. **Promise**：ES6引入了原生的Promise对象，简化了异步操作的处理，避免了回调地狱。
9. **扩展运算符**：ES6中可以使用...来展开数组或对象，简化了数据处理的逻辑。
10. **Map 和 Set**：ES6引入了Map和Set数据结构，提供了更灵活的数据存储和处理方式。
11. **Symbol**：ES6引入了Symbol数据类型，用于表示唯一的标识符，有助于避免命名冲突。
12. **Generators**：ES6引入了生成器函数，使得迭代器的创建和管理更加灵活。

这些新特性丰富了JavaScript的功能和表达能力，使得开发人员能够更加高效地编写清晰、简洁且可维护的代码。

## 前端持续化集成

## ngnix简单配置

以下是NGINX的简单配置要点：

1. **基本服务器块配置**：定义NGINX服务器块（server block），包括监听的端口和服务器名称。
2. **根目录和索引文件**：指定服务器块的根目录和默认索引文件。
3. **位置块配置**：定义不同URL路径的行为，可以包括代理、重定向或其他操作。
4. **日志记录**：配置访问日志和错误日志的存储位置和格式。
5. **反向代理**：配置NGINX作为反向代理服务器，将请求转发给后端服务器。
6. **负载均衡**：配置NGINX进行负载均衡，分发流量到多个后端服务器。
7. **SSL/TLS**：配置HTTPS连接，包括证书和加密协议的设置。
8. **Gzip压缩**：启用对传输内容的Gzip压缩，以提高性能。
9. **缓存**：配置NGINX缓存静态内容，减少对后端服务器的请求。
10. **安全设置**：包括限制访问、防止DDoS攻击、设置HTTP头部等安全相关配置。

以下是一个简单的 NGINX 配置示例：

```
server {
    listen 80;
    server_name example.com www.example.com;

    location / {
        root /var/www/html;
        index index.html index.htm;
    }

    location /images/ {
        alias /var/www/images/;
    }

    location /app/ {
        proxy_pass http://localhost:3000;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
    }

    access_log /var/log/nginx/access.log;
    error_log /var/log/nginx/error.log;
}
```

在这个简单的配置中，我们定义了一个NGINX服务器块，监听80端口，并处理example.com和www.example.com的请求。根目录为/var/www/html，如果请求路径是/images/，则会映射到/var/www/images/目录下。同时，对/app/路径的请求将被代理到本地的3000端口上。访问日志和错误日志分别记录在/var/log/nginx/access.log和/var/log/nginx/error.log。

这个简单的示例展示了NGINX配置文件的基本结构和一些常见指令的使用。

## node了解了多少

Node.js是一个基于Chrome V8引擎的JavaScript运行时环境，用于构建快速、可扩展的网络应用程序。以下是对Node.js的简要描述：

1. **事件驱动**：Node.js基于事件驱动架构，使用非阻塞I/O模型，能够处理大量并发连接而不产生额外线程开销。
2. **单线程**：Node.js本身是单线程的，但通过事件循环和异步操作，能够高效地处理大量请求。
3. **跨平台**：Node.js可以在多个平台上运行，并且具有良好的可移植性。
4. **构建服务器端应用**：Node.js通常用于构建服务器端应用程序，如Web服务器、API服务器等。
5. **NPM**：Node.js拥有强大的包管理工具npm，使得开发者能够轻松地共享、安装和管理代码包。
6. **前后端一体**：由于Node.js使用JavaScript作为开发语言，因此可以实现前后端一体化的开发，提高了开发效率。
7. **社区支持**：Node.js拥有庞大的社区支持和丰富的第三方库，可以满足各种开发需求。

总的来说，Node.js是一个灵活、高效的平台，适合构建高性能、可伸缩的网络应用程序。

## 小程序怎么和用户关联

微信小程序与用户关联的过程主要涉及以下几个方面：

1. **用户授权**：用户在使用微信小程序时，需要进行授权。小程序可以通过调用 `wx.login` 方法获取用户的临时登录凭证 code。
2. **获取用户信息**：通过 `wx.getUserInfo` 方法获取用户信息，包括昵称、头像等，并将其存储在小程序端或者传递给后端服务器。
3. **唯一标识**：每个用户在小程序中都有一个唯一的用户标识 OpenID，可以通过 `wx.login` 获取到用户的OpenID，然后可以将其与其他用户数据进行关联。
4. **存储用户信息**：小程序可以将用户的OpenID和其他信息存储在小程序端的缓存中，也可以将这些信息传递给后端服务器进行存储和处理。
5. **后端服务器关联**：通常情况下，小程序会将用户信息传递给后端服务器，后端服务器负责将用户信息与特定的用户账号或其他业务数据进行关联。

总的来说，微信小程序通过用户授权获取用户信息，然后将用户信息传递给后端服务器，后端服务器在接收到用户信息后，将其与具体的用户账号或其他业务数据进行关联，从而实现微信小程序与用户的关联。

多个微信小程序要与用户关联，可以考虑以下方法：

1. **UnionID**：如果这些小程序属于同一开发者账号，可以通过UnionID来实现用户的统一关联。当用户在不同的小程序中授权登录后，可以通过UnionID来识别和关联同一个用户。
2. **统一后端服务**：为这些小程序建立一个统一的后端服务，用户在任何一个小程序中进行授权登录后，后端服务负责将用户信息进行统一管理和关联。
3. **第三方登录**：使用微信提供的第三方登录功能，将用户信息传递给第三方服务器进行关联，从而实现多个小程序之间的用户关联。
4. **微信开放平台**：如果这些小程序属于同一企业或品牌，可以考虑将它们纳入同一个微信开放平台账号下，通过开放平台的相关功能实现用户关联。

总的来说，多个微信小程序与用户关联需要综合考虑业务场景和微信提供的相关功能，例如UnionID、统一后端服务、第三方登录等方式，以实现用户在多个小程序之间的统一关联

## 首页加载怎么优化

首页加载速度的优化对于用户体验至关重要。以下是一些常见的首页加载优化策略：

1. **图像优化**：压缩图片大小、选择合适的图片格式（如WebP），使用懒加载技术以及使用CSS Sprites或者Icon Fonts来减少HTTP请求次数。
2. **资源压缩和合并**：对JavaScript和CSS文件进行压缩，合并多个文件以减少HTTP请求次数。
3. **CDN加速**：使用内容分发网络（CDN）来加速静态资源的传输，将资源缓存到距离用户更近的服务器上。
4. **延迟加载**：将不是立即需要的资源进行延迟加载，例如在页面加载完成后再加载某些模块或内容。
5. **DNS预解析**：使用DNS预解析来提前解析域名，加速资源的获取。
6. **服务端渲染**：对于需要SEO的页面，可以考虑使用服务端渲染技术，提前生成HTML，减少客户端渲染时间。
7. **移除不必要的插件和脚本**：检查并移除不必要的第三方插件和脚本，减少页面加载时的额外开销。
8. **代码优化**：精简JavaScript和CSS，避免不必要的计算和样式处理，减少页面渲染时间。
9. **HTTP缓存**：配置合适的缓存策略，利用浏览器缓存机制来减少资源重复加载。
10. **异步加载**：使用异步加载脚本，尽量将非关键代码推迟到页面加载完成后再执行。

这些优化策略可以帮助提高首页加载速度，改善用户体验，并且有助于提高网站的性能指标。

## H5怎么适配

H5适配是指将网页或应用在不同设备上的显示效果进行优化，以确保在各种屏幕尺寸和分辨率下都能够提供良好的用户体验。以下是一些常见的H5适配方法：

1. **响应式布局**：使用CSS3媒体查询等技术，根据设备的屏幕尺寸和方向来动态调整页面布局和样式。
2. **流式布局**：使用相对单位（如百分比、em等）而不是固定单位（像素），使得页面元素能够根据视口大小进行自适应调整。
3. **弹性图片**：使用max-width: 100%来确保图片在不同屏幕尺寸下能够按比例缩放，避免变形或溢出。
4. **视口设置**：使用meta标签设置viewport，确保页面在移动设备上以正确的比例和缩放显示。

```
<meta name="viewport" content="width=device-width, initial-scale=1.0">
```

1. **rem布局**：使用rem作为单位，根据根元素的字体大小来进行相对布局，可以根据屏幕大小动态调整页面元素大小。
2. **CSS Flexbox和Grid布局**：使用Flexbox和Grid布局可以更灵活地实现页面元素的自适应排列和对齐。
3. **CSS媒体查询**：根据不同的屏幕尺寸和方向，应用不同的CSS样式，以适配不同的设备。
4. **移动优先**：在设计和开发时优先考虑移动设备，确保页面在移动设备上有良好的显示效果和用户体验。

这些方法可以帮助H5页面在不同设备上实现良好的适配效果，提高用户体验，并确保内容在各种屏幕上都能够清晰展示。

## 移动端1px边框问题

通常是由于设备像素密度（DPR）的差异引起的。这个问题主要出现在高密度屏幕（如Retina屏幕）上，其原因如下：

1. **物理像素和逻辑像素的差异**：在高密度屏幕上，一个CSS像素可能对应多个物理像素，这是为了在有限的屏幕空间内显示更多的图像细节。
2. **边框渲染**：当使用CSS中的1px边框时，如果直接以1个CSS像素来渲染，那么在高DPR的屏幕上，这条边框会被渲染成多个物理像素，导致看起来比1px要粗。
3. **设备像素比（Device Pixel Ratio，DPR）**：DPR指的是物理像素和逻辑像素的比值，例如iPhone的DPR通常为2或3，这意味着1个CSS像素可能对应2或3个物理像素。
4. **浏览器缩放**：有些浏览器在缩放页面时会对1px边框进行模糊处理，导致边框显示不清晰。

由于这些因素，1px边框在高密度屏幕上容易出现模糊或变粗的情况，需要采取特定的解决方案来解决这一问题，确保在各种设备上都能够获得清晰的边框显示效果。

## 如果有些手机屏幕太高，底部空出来很多空间怎么做适配

## 重排和重绘的概念和区别

## 重排和重绘的触发条件

重排（reflow）和重绘（repaint）是与网页性能优化相关的重要概念。它们的区别在于：

- **重排（Reflow）**：当DOM结构发生变化，例如改变元素的尺寸、内容或页面布局，浏览器需要重新计算元素的几何属性，然后再次进行布局。这个过程称为重排。重排会影响整个页面的布局，因此代价较高。
- **重绘（Repaint）**：当元素的外观发生变化，例如修改颜色、背景等样式，但没有影响其布局时，浏览器只需要重新绘制受影响的部分，而不用重新计算元素的几何属性和布局。这个过程称为重绘。重绘的开销通常比重排小。

触发条件如下：

**重排（Reflow）**可能被触发的情况包括：

1. 添加或删除可见的DOM元素。
2. 元素位置发生变化。
3. 元素尺寸发生变化（包括外边距、内边距、边框大小、宽度和高度的改变）。
4. 内容的改变，比如文本改变导致了文字宽度的变化。
5. 页面初始化。
6. 浏览器窗口尺寸改变。

**重绘（Repaint）**可能被触发的情况包括：

1. 修改元素的背景色、字体颜色等。
2. 隐藏或显示元素。
3. 改变元素的透明度。
4. 添加或修改CSS伪类。

减少重排和重绘对于提高页面性能非常重要，可以通过合理的CSS布局、批量处理DOM变化、避免强制同步布局等方式来减少这两种操作的频率，以提升页面的渲染性能。

## BFC的概念怎么理解？怎么设置BFC

BFC（块级格式化上下文）是CSS中的一个重要概念，用于描述在布局过程中块级盒子的渲染规则。理解BFC可以帮助开发者更好地控制元素在页面中的布局和定位。

**理解BFC：**

- **独立容器**：BFC内部的元素在布局时不会影响外部元素，反之亦然。
- **垂直方向**：BFC内部的盒子在垂直方向上的边距（margin）会发生重叠，但与外部不会发生重叠。
- **浮动清除**：BFC能够包含浮动的子元素，防止父元素高度塌陷。

**如何创建BFC：**

1. **使用float属性**：设置元素的float属性为left或right可以创建BFC。
2. **使用overflow属性**：设置元素的overflow为auto、hidden、scroll等值，可以创建BFC。
3. **使用display属性**：将元素的display属性设置为inline-block、table-cell、table-caption、flex、grid等值，也可以创建BFC。
4. **使用position属性**：将元素的position属性设置为absolute或fixed，同样可以创建BFC。

示例代码：

```css
/* 使用overflow创建BFC */
.element {
  overflow: hidden;
}

/* 使用float创建BFC */
.element {
  float: left;
}

/* 使用display创建BFC */
.element {
  display: inline-block;
}

/* 使用position创建BFC */
.element {
  position: absolute;
}
```

通过以上方式，可以有效地创建BFC，从而改变元素的布局特性，避免一些常见的布局问题，如外边距重叠、高度塌陷等。

## margin塌陷的原因和解决办法

## 设置水平垂直居中方式

## 判断数组的方法

## typeof和instanceof的区别

## 如何对H5页面做响应式

## em和rem的区别

## forin和forof的区别 以及使用方法

## 什么样的情况对象可遍历

## 在js中迭代器是什么

## 什么样的情况会出现浏览器跨域问题 如何解决

## Vue3相对Vue2的diff算法有哪些优化

## Vue2为什么不建议同时使用v-if和v-for

## Webpack的loader和plugin的区别

## Webpack和Vite在开发环境的区别

## Webpack的优化问题

## HTTP和HTTPS的区别

## UDP和TCP的区别

## React的函数组件和类组件有什么区别

## 如何实现函数组件的生命周期

## 项目中使用indexDB的场景，为什么使用indexDB，而不使用别的方式







## eggjs洋葱模型

## jsbridge原理

## 线上出问题本地没有问题怎么解决

## c端兼容性出现问题怎么解决

## 线上出现问题 怎么回滚代码

## 泛型使用场景

## interface 和 type 有啥区别

在 TypeScript 中，`interface` 和 `type` 都可以用来定义对象的结构或形状，但它们有一些区别：

1. `interface`：
   - `interface` 主要用于描述对象的形状（Shape），可以包含属性、方法、索引签名等。
   - 可以被类（class）实现（implement），用于定义类的契约（contract）。
   - 可以进行扩展（extend）另一个 `interface`。
   - 不能重复定义同名的 `interface`。

示例：

```javascript
interface Person {
  name: string;
  age: number;
}

const person: Person = { name: 'Alice', age: 30 };
```

1. `type`：
   - `type` 可以用来给现有的类型起一个别名，也可以用来定义新的类型。
   - 可以使用联合类型（Union）、交叉类型（Intersection）、元组（Tuple）等特性。
   - 可以进行交叉类型（Intersection）、联合类型（Union）等操作。
   - 可以使用 `typeof` 操作符获取现有变量的类型。

示例：

```javascript
type Point = {
  x: number;
  y: number;
};

const p: Point = { x: 10, y: 20 };
```

总的来说，`interface` 更适合用于描述对象的形状和定义类的契约，而 `type` 更适合用于给类型起别名、定义联合类型、交叉类型等复杂类型场景。在实际使用中，你可以根据具体的需求和场景选择使用 `interface` 或 `type`。

## 前端性能优化

前端性能优化是提高网站速度和用户体验的关键。以下是一些常见的前端性能优化技巧：

1. **减少 HTTP 请求：** 合并文件、使用 CSS 精灵、减少页面中的资源请求次数，可以减少加载时间。
2. **使用 CDN 加速：** 使用内容分发网络（CDN）可以加速静态资源的加载速度，提高网站性能。
3. **压缩资源：** 压缩 CSS、JavaScript 和图片等资源可以减少文件大小，加快加载速度。
4. **延迟加载：** 对于不是立即需要的资源，可以延迟加载，比如图片懒加载、按需加载 JavaScript 等。
5. **优化图片：** 使用适当的图片格式、压缩图片、使用响应式图片等方式来优化图片加载。
6. **缓存优化：** 使用浏览器缓存和服务端缓存来减少重复加载资源的次数。
7. **减少重绘和回流：** 避免频繁的 DOM 操作和样式修改，可以减少页面的重绘和回流，提高性能。
8. **使用异步加载：** 使用异步加载脚本、使用 Web Workers 来进行后台计算等方式可以提高页面的响应速度。
9. **优化 CSS 和 JavaScript：** 避免使用过多的 CSS 和 JavaScript 库，精简代码、减少不必要的操作，可以提高性能。
10. **移动端优化：** 针对移动设备进行优化，比如使用响应式设计、减少不必要的动画效果等。

通过结合以上的优化技巧，可以有效地提升网站的性能，加快页面加载速度，提升用户体验。

## 对TS泛型的理解?及常用的场景

泛型（Generics）是一种在编程中使用类型参数化的技术，它可以让你编写更灵活、可重用的函数、类或接口。通过泛型，你可以编写与类型无关的代码，同时保留类型安全性。在 TypeScript 中，泛型允许你在函数、类、接口等地方使用类型参数，从而增加代码的灵活性和可重用性。

### 泛型的理解

泛型可以让你编写一个函数或类，这个函数或类可以适用于多种不同的数据类型，而不是固定地绑定在一种特定的数据类型上。通过在函数或类定义中使用类型参数，你可以在调用时指定具体的类型，从而使函数或类在不同场景下能够适应不同的数据类型。

### 示例

下面是一个简单的示例，展示了如何使用泛型来创建一个函数，用于交换两个元素的位置：

```
function swap<T>(arr: T[], index1: number, index2: number): void {
    const temp = arr[index1];
    arr[index1] = arr[index2];
    arr[index2] = temp;
}

// 使用泛型函数
const numberArray: number[] = [1, 2, 3, 4];
swap<number>(numberArray, 0, 1);
console.log(numberArray); // 输出：[2, 1, 3, 4]

const stringArray: string[] = ['apple', 'banana', 'cherry'];
swap<string>(stringArray, 1, 2);
console.log(stringArray); // 输出：['apple', 'cherry', 'banana']
```

在这个示例中，`swap` 函数使用了一个类型参数 `T`，这使得函数可以适用于不同类型的数组。当调用 `swap` 函数时，通过指定具体的类型参数，可以在不同类型的数组上进行元素位置的交换。

### 常用场景

泛型在实际开发中有许多常见的应用场景，其中一些包括：

1. **集合类（如数组、列表、栈、队列等）：** 使用泛型可以创建通用的集合类，这样可以在不同类型的集合上进行操作，提高代码的复用性。
2. **函数工具库：** 泛型可用于创建通用的函数操作，如映射、过滤、排序等操作，适用于不同类型的数据。
3. **Promise 和异步操作：** 使用泛型可以在 Promise 中指定返回值的类型，从而提供更好的类型检查和推断。
4. **React 组件：** 在 React 中，泛型可以用于创建可重用的组件，使组件能够适用于不同类型的数据。
5. **数据结构和算法：** 泛型可以在实现数据结构和算法时提供灵活性，使其适用于不同类型的数据。

总的来说，泛型在 TypeScript 中是一个非常强大且常用的特性，可以帮助你编写更灵活、可重用的代码，同时保持类型安全。

## webpack性能优化相关的配置

对于 Webpack 的性能优化，可以通过一些配置和优化技巧来提升构建速度和减少资源体积。以下是一些常用的 Webpack 性能优化配置和技巧：

1. **使用最新版本的 Webpack：** 确保你正在使用最新版本的 Webpack，因为新版本通常会包含性能优化和 bug 修复。
2. **合理使用 Loader：** 避免不必要的 Loader，只加载必要的资源，尽量减少 Loader 的使用。
3. **优化 Loader 配置：** 配置 Loader 时，可以使用 `include` 和 `exclude` 来明确指定 Loader 处理的文件范围，避免不必要的文件解析。
4. **合理使用插件：** 选择合适的插件，如使用 `MiniCssExtractPlugin` 提取 CSS 文件，使用 `terser-webpack-plugin` 压缩 JavaScript 等。
5. **代码分割（Code Splitting）：** 使用 Webpack 的代码分割功能，将代码拆分成多个 bundle，实现按需加载，减少初始加载时间。
6. **懒加载（Lazy Loading）：** 使用动态 import 或 React.lazy() 实现懒加载，根据需要加载组件或模块，减少初始加载时间。
7. **优化图片资源：** 使用 `url-loader` 或 `file-loader` 处理图片资源，并考虑使用图片压缩工具优化图片大小。
8. **缓存：** 使用 `contenthash` 或 `chunkhash` 来生成文件名，实现文件内容变化时文件名变化，利用浏览器缓存。
9. **优化打包体积：** 使用 Tree Shaking、代码压缩、去除无用代码等技术来减小打包体积。
10. **多进程/多实例构建：** 使用 `thread-loader` 或 `parallel-webpack` 等工具，利用多核 CPU 加速构建过程。

通过以上的配置和优化技巧，可以有效地提升 Webpack 的构建性能，加快项目的打包速度，减少资源体积，提升用户体验。

## 常用的行内/块级元素;行内元素和块级元素的表现差异

在 HTML 中，元素可以分为行内元素（inline elements）和块级元素（block-level elements）。它们在页面中的表现形式和特点有所不同。

### 行内元素（inline elements）：

- 特点

  ：

  - 默认情况下，行内元素不会导致文本换行，它们会在同一行内水平排列。
  - 行内元素的宽度、高度以及顶部和底部边距（margin）不可设置，只能设置左右边距。
  - 行内元素只能容纳文本或者其他行内元素，不能容纳块级元素。

- **常见的行内元素**：`<span>`, `<a>`, `<strong>`, `<em>`, `<img>`, `<input>`, `<button>` 等。

### 块级元素（block-level elements）：

- 特点

  ：

  - 块级元素会导致文本换行，每个块级元素都会独占一行。
  - 块级元素的宽度、高度以及边距（margin）都可以设置。
  - 块级元素可以容纳文本、行内元素以及其他块级元素。

- **常见的块级元素**：`<div>`, `<p>`, `<h1>` - `<h6>`, `<ul>`, `<ol>`, `<li>`, `<table>`, `<form>` 等。

### 行内元素和块级元素的表现差异：

1. **布局**：块级元素会独占一行，而行内元素不会。
2. **宽高**：块级元素的宽度、高度以及边距可以设置，而行内元素只能设置左右边距。
3. **文本流**：块级元素会导致文本换行，行内元素不会。
4. **嵌套**：块级元素可以包含其他块级元素和行内元素，而行内元素只能包含文本或其他行内元素。

在实际开发中，理解行内元素和块级元素的特点和表现差异有助于更好地控制页面布局和样式。合理地使用行内元素和块级元素可以更好地构建出符合设计要求的页面结构。



## .css的选择器有哪些?优先级如何?

CSS 中常见的选择器包括：

1. **元素选择器**：根据元素的标签名选择元素，例如 `p` 选择所有 `<p>` 元素。
2. **类选择器**：以点 `.` 开头，选择具有指定类的元素，例如 `.my-class` 选择所有具有 `my-class` 类的元素。
3. **ID 选择器**：以井号 `#` 开头，选择具有指定 ID 的元素，例如 `#my-id` 选择具有 `my-id` ID 的元素。
4. **属性选择器**：根据元素的属性值选择元素，例如 `[type="text"]` 选择所有 `type` 属性值为 `text` 的元素。
5. **伪类选择器**：用于选择元素的特定状态，例如 `:hover` 选择鼠标悬停在元素上的状态。
6. **伪元素选择器**：用于选取元素的特定部分，例如 `::before` 在元素之前插入内容。

选择器的优先级按照以下顺序（从高到低）：

1. **!important**：具有 `!important` 标记的样式具有最高优先级。
2. **内联样式**：直接在元素上使用 `style` 属性设置的样式。
3. **ID 选择器**：以 `#` 开头的选择器。
4. **类选择器、属性选择器、伪类选择器**：包括类选择器（`.`）、属性选择器（`[]`）、伪类选择器（`:`）。
5. **元素选择器、伪元素选择器**：包括元素选择器和伪元素选择器。
6. **通配符选择器**：`*`。
7. **继承的样式**：从父元素继承的样式。

在编写 CSS 样式时，了解选择器的优先级是非常重要的，可以帮助你更好地控制样式的应用顺序和覆盖关系。

## 如何判断一个变量是否为对象?如何复制这个对象

要判断一个变量是否为对象，可以使用 `typeof` 操作符来检查变量的类型是否为 "object"，但需要注意的是，`typeof null` 也会返回 "object"，所以需要进一步检查变量是否为 `null`。

以下是判断变量是否为对象的示例代码：

```
function isObject(variable) {
  return variable !== null && typeof variable === 'object';
}

// 示例
const obj = { key: 'value' };
const arr = [1, 2, 3];

console.log(isObject(obj)); // true
console.log(isObject(arr)); // true
console.log(isObject(null)); // false
console.log(isObject('string')); // false
```

如果要复制一个对象，可以使用对象的展开运算符 `...` 或者 `Object.assign()` 方法来实现。这两种方法都是浅拷贝，即只复制对象的第一层属性，如果对象的属性值是对象或数组等引用类型，那么复制后的对象仍然会共享这些引用类型的数据。

使用展开运算符 `...` 复制对象的示例代码如下：

```
const originalObj = { key: 'value' };
const copiedObj = { ...originalObj };

console.log(copiedObj); // { key: 'value' }
```

使用 `Object.assign()` 方法复制对象的示例代码如下：

```
const originalObj = { key: 'value' };
const copiedObj = Object.assign({}, originalObj);

console.log(copiedObj); // { key: 'value' }
```

通过以上方法，你可以判断一个变量是否为对象，并且复制这个对象。

## 0.1+0.2 === 0.3的返回值是什么?为什么?该如何解决?

在大多数编程语言中，包括JavaScript，0.1 + 0.2 的结果并不会精确等于 0.3，这是由于浮点数精度问题导致的。在JavaScript中，这是因为数字以 IEEE 754 浮点数的形式表示，有时会导致精度丢失。

当执行 0.1 + 0.2 时，实际计算结果是一个非常接近但不完全等于 0.3 的值，可能是一个非常接近 0.3 的小数。因此，表达式 0.1 + 0.2 === 0.3 的返回值是 `false`。

要解决这个问题，可以通过以下方法之一：

1. **舍入到特定精度：** 可以将结果舍入到特定的小数位数，然后进行比较。例如，可以使用 `toFixed()` 方法将结果舍入到指定的小数位数。

   ```
   const result = 0.1 + 0.2;
   const expectedResult = 0.3;
   console.log(result.toFixed(1) === expectedResult.toFixed(1)); // true
   ```

2. **使用库：** 可以使用像 `math.js` 或 `decimal.js` 这样的库来处理精确的数学运算。

3. **比较差值：** 可以比较两个数之间的差值是否在一个非常小的范围内，而不是直接比较它们是否相等。

   ```
   const result = 0.1 + 0.2;
   const expectedResult = 0.3;
   console.log(Math.abs(result - expectedResult) < Number.EPSILON); // true
   ```

通过以上方法，你可以更好地处理浮点数精度问题，确保在比较浮点数时得到正确的结果。

## 后端用64位整数作为id传给前端会有什么问题?该如何解决?

当后端使用64位整数作为ID传递给前端时，可能会遇到一些问题，特别是在JavaScript中处理大整数时会出现精度丢失的情况。JavaScript中的Number类型是双精度浮点数，最大安全整数是 2^53 - 1，即 9007199254740991。当超过这个范围时，JavaScript无法精确表示这个整数，从而导致精度丢失。

为了解决这个问题，可以考虑以下几种方法：

1. **使用字符串传递ID：** 将64位整数作为字符串传递给前端，这样可以避免JavaScript中处理大整数时的精度丢失问题。
2. **分割ID传递：** 如果64位整数表示的ID可以分割为更小的部分，可以将这些部分分开传递给前端，然后在前端进行合并处理。
3. **使用BigInt类型：** 如果浏览器支持，可以考虑使用JavaScript的BigInt类型来表示大整数，这样可以避免精度丢失问题。
4. **前后端协商转换：** 在前后端协商的情况下，可以约定一种转换规则，比如将64位整数转换为字符串或者其他格式传递给前端，以避免精度丢失问题。

选择合适的方法取决于具体情况和需求，可以根据实际情况来决定如何传递和处理64位整数ID。

## 什么是闭包?典型的使用场景

闭包是指函数和其周围状态（词法环境）的组合。这意味着函数可以访问其外部函数作用域中的变量，即使外部函数已经执行完毕。闭包在 JavaScript 中是非常常见且强大的特性，常用于保存状态、封装变量、实现模块化等。

典型的闭包使用场景包括：

1. **保存状态：** 通过闭包可以创建一个函数，该函数可以访问并修改其创建时所处的作用域中的变量，从而实现状态的保存。
2. **封装变量：** 闭包可以用来封装变量，避免全局污染，实现信息隐藏和数据保护。
3. **回调函数：** 在事件处理、定时器、异步请求等场景中，闭包可以用来保存和操作回调函数所需的上下文信息。
4. **模块化：** 通过闭包可以实现模块化，将变量和方法封装在闭包内部，提供私有性和封装性。

示例代码：

```
function createCounter() {
  let count = 0;
  
  function increment() {
    count++;
    console.log(count);
  }
  
  return increment;
}

const counter = createCounter();
counter(); // 输出 1
counter(); // 输出 2
```

在这个例子中，`createCounter` 函数返回了一个内部定义的 `increment` 函数，该函数形成了一个闭包，可以访问并修改 `count` 变量。每次调用 `counter` 函数，都会更新并打印计数器的值。

## new的执行过程?如何实现

在JavaScript中，当使用`new`关键字来实例化一个对象时，会经历以下步骤：

1. 创建一个新的空对象。
2. 将这个新对象的`__proto__`属性指向构造函数的`prototype`属性。
3. 将构造函数中的`this`指向这个新对象。
4. 执行构造函数内部的代码，为这个新对象添加属性和方法。
5. 如果构造函数返回了一个对象，则返回这个对象；否则返回这个新对象。

下面是一个简单的例子，展示了如何手动实现`new`的过程：

```
function myNew(constructor, ...args) {
    // 创建一个新对象，原型指向构造函数的 prototype
    const obj = Object.create(constructor.prototype);
    
    // 将构造函数中的 this 指向这个新对象
    const result = constructor.apply(obj, args);
    
    // 如果构造函数返回了一个对象，则返回这个对象；否则返回新对象
    return result instanceof Object ? result : obj;
}

// 使用自定义的 myNew 方法来实例化一个对象
function Person(name) {
    this.name = name;
}

const person = myNew(Person, 'Alice');
console.log(person.name); // 输出 'Alice'
```

通过上面的例子，可以看到我们手动实现了`new`的过程，创建了一个新对象并成功实例化了一个`Person`对象。